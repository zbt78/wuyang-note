- 黎明灰烬：[通用矩阵乘（GEMM）优化算法](https://zhenhuaw.me/blog/2019/gemm-optimization.html)

## 基于软件优化的方法

- 展开循环利用**寄存器**存储数据减少访存

## 问题

- （一）
	0. 为什么分块能加速？
		0. 想象一下取数的过程就可以理解了。
	1. 为什么分块之后还能保证数据的正确性？
		0. 分块之后点的最终计算结果为各个分块该点处的计算结果的和。
	2. 为什么naive算法需要2mnk次读操作，我感觉是mnk才对
	3. 那为什么还要划分bk？

- （二）
	0. 为什么As需要转置
	1. `#pragma unroll`的作用
		0. 在默认情形下，编译器对已知次数的小循环进行展开，`#pragma unroll`可以用来控制任意一个给定的循环。但 `#pragma unroll`必须放在被控制的循环的前面，后面可以带展开次数选项。后跟参数1则编译器不会展开循环。
		1. 如果没有参数，并且循环次数是一常数时编译器会将循环完全展开，如果不是常数就根本不会展开。
	2. 为什么一次大迭代中，所有线程的同一次搬运用一个寄存器？为什么不同的搬运用不同的寄存器？
	3. 大迭代过程中，转置的逻辑的实现和预取数据时有何不同
	4. 将存储在临时寄存器的数据搬运到shared memory中时的转置与取数据时的转置有什么不同
	5. 将存储在临时寄存器的数据搬运到shared memory中处的代码是不是不对应文字呀
	6. accum会不会开的太小了？

- （三）
	0. 关于汇编的部分可以先跳过，关于CUDA C层面第二个优化方法以后要自己实现一下
	1. 大矩阵SGEMM看看还有没有可以做的工作
