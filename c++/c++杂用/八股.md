## [[模板]]
### explicit
只能用于修饰只有一个参数的类构造函数（有一个例外就是，当除了第一个参数以外的其他参数都有默认值的时候此关键字依然有效），它的作用是表明该构造函数是显示的，而非隐式的。作用是防止类构造函数的隐式自动转换。
```c++
class B {
	explicit B(int b) {
		b_ = b;
	}
	int b_;
};

void fun(B b) {
	cout<<b.b_;
}

int mian() {
	fun(42);  // 都可以
	fun(B(42)); // 有explicit只能用这种方式	
}
```

### 成员变量初始化的顺序
成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。类中const成员常量必须在构造函数初始化列表中初始化。**类中static成员变量，只能在类外初始化。***

### malloc和new的区别是什么？
- Malloc/free是标准库函数，new/delete是C++运算符
- Malloc分配内存失败返回空，new失败抛异常
- New/delete会调用构造析构函数，malloc/free不会，所以他们无法满足动态对象的要求。
- New返回有类型的指针，malloc返回无类型的指针
- 分配内存的位置：malloc从堆上动态分配内存，new是从自由存储区为对象动态分配内存（取决于operator new的实现，可以为堆还可以是静态存储区）
- New申请内存的步骤：调用operator new函数，分配一块足够大，且原始的，未命名的内存空间来存储特定类型的对象。运行相应的构造函数来构造对象，并为其传入初值，返回一个指向该对象的指针。
- Delete：先调用对象的析构函数，再调用operator delete函数释放内存空间

### STL
仿函数，算法，迭代器，空间配置器，容器，配接器

### map和unordered_map
Map内部实现是一个红黑树，内部所有的元素都是有序的，而unordered_map则是内部实现了一个哈希表，内部存储元素是无序的。

Map优点：有序性，其次是内部实现的是一个红黑树，使得很多操作都可以在logn的复杂度下可以实现效率较高。

Map缺点：空间占用率高

Unorderedmap优点：查找效率非常高。缺点：哈希表的建立比较费时间。

### push_back()和emplace_back()
底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。
```c++
#include <vector> 
#include <iostream> 
using namespace std;
class testDemo
{
public:
    testDemo(int num):num(num){
        std::cout << "调用构造函数" << endl;
    }
    testDemo(const testDemo& other) :num(other.num) {
        std::cout << "调用拷贝构造函数" << endl;
    }
    testDemo(testDemo&& other) :num(other.num) {
        std::cout << "调用移动构造函数" << endl;
    }
private:
    int num;
};

int main()
{
    cout << "emplace_back:" << endl;
    std::vector<testDemo> demo1;
    demo1.emplace_back(2);  

    cout << "push_back:" << endl;
    std::vector<testDemo> demo2;
    demo2.push_back(2);
}
/* output
emplace_back:
调用构造函数
push_back:
调用构造函数
调用移动构造函数

*/
```

### C++空类
C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。这是由于：

-   new需要分配不同的内存地址，不能分配内存大小为0的空间
-   避免除以 sizeof(T)时得到除以0错误

故使用一个字节来区分空类。

如果你只是声明一个空类，不做任何事情的话，编译器会自动为你生成一个默认**构造函数**、一个默认**拷贝构造函数**、一个默认**赋值操作符**、一对**取址运算符**和一个默认**析构函数**。这些函数只有在第一次被调用时，才会被编译器创建。所有这些函数都是inline和public的。
```c++
class Empty
{
};

// 编译后

class Empty
{
public:
    Empty();                          // 缺省构造函数
    Empty(const Empty&);              // 拷贝构造函数
    ~Empty();                         // 析构函数
    Empty& operator=(const Empty&);   // 赋值运算符
    Empty* operator&();               // 取址运算符
    const Empty* operator&() const;   // 取址运算符 const
};
```

## [[虚函数]]

## 待归类
### 如何保证类的对象只能被开辟在堆上？
（将构造函数声明为私有、单例）
将构造函数设置为私有，这样只能使用new运算符来建立对象，但是我们必须准备一个destory函数来进行内存的释放，然后将析构函数设置为protected，提供一个public的static函数来完成构造，类似于单例模式。

如果在栈上分配呢？则是重载new操作符，使得new操作符的功能为空，这样就使得外层程序无法在堆上分配对象，只可以在栈上分配。

- 栈：是由编译器在需要时自动分配，不需要时自动清除的变量存储区。通常存放局部变量、函数参数等。
- 堆：是由new分配的内存块，由程序员释放（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，        资源将由操作系统在程序结束后自动回收。
- 自由存储区：是由malloc等分配的内存块，和堆十分相似，用free来释放。
- 全局/静态存储区：全局变量和静态变量被分配到同一块内存中（在C语言中，全局变量又分为初始化的和未初始化的，C++中没有这一区分）。
- 常量存储区：这是一块特殊存储区，里边存放常量，不允许修改。

**new**是运算符，可以被重载。



### extern C
用来实现在C++代码段中用C语言的方式来编译代码，是C++为了兼容C语言所加入的关键字。

### 编译器是如何实现重载的？
在编译时，编译器如果遇到了函数，就会在符号表里面命名一个符号来存放函数的地址，如果函数的使用在定义之前编译，无法在符号表中找到对应函数地址，则先标记为“？”（暂时未知），在全部编译结束后的链接过程将“？”在符号表里找到并替代为相应的函数地址，如果函数的定义在使用之前编译，则可以直接在符号表里找到对应函数地址直接使用，而在C语言中的符号表是以函数名为符号来存储函数地址，函数名相同的重载函数的地址应该不同，于是符号表中存在两个同符号的函数地址，在查找使用时会存在歧义和冲突。而C++符号表中的符号不是以函数名命名的，称为函数名修饰规则，虽然函数名相同，但是函数参数等其他属性不同，取的符号也不同，所以不会产生查询歧义的问题，使得函数可以重载。

### 静态成员函数
类内普通成员函数可以调用类内静态变量，因为类内静态变量在编译时就已经完成了初始化和内存分配，类内普通函数调用类内静态变量说明类已经完成实例化，所以可以调用。静态函数可以直接访问静态变量，静态函数不能直接访问非静态变量，但是可以通过将类实例化对象后，静态函数去访问对象的非静态成员变量。
```c++
#include <vector>
#include <iostream>

using namespace std;

class Person {
public:
    static int count;
    static int sum;
    int age;
    Person(int age) :age(age) {
        count++;
        sum += age;
    }

    static int avg() {
        if(count == 0) return 0;
        return sum / count;
    }
};

int Person::count = 0;
int Person::sum = 0;

int main() {

    Person p(10);
    cout<<p.age<<" "<<Person::count<<" "<<Person::sum<<" "<<Person::avg()<<endl;

}
```

### C++的子类指针指向父类
1. 直接用基类指针引用基类对象
2. 直接用派生类指针引用派生类对象
3. 用基类指针引用一个派生类对象，由于派生类对象也是基类的对象，所以这种引用是安全的，但是只能引用基类成员。若试图通过基类指针引用那些只在派生类中才有的成员，编译器会报告语法错误。（解决该问题的答案是虚函数和多态性）
4. 用派生类指针引用基类的对象。这种引用方式会导致语法错误。派生类指针必须先强制转换为基类指针，这种方法是不安全的。 

> 而在侯捷的深入浅出MFC中第二章C++重要性质中:
1. 如果你以一个"基类之指针"指向一个"派生类之对象"，那么经由该指针你只能调用该基类所定义的函数
2. 如果你以一个“派生类之指针”指向一个“基类之对象”，你必须先做明显的转型操作(explicit cast)，这种作法很危险。
3. 如果基类和派生类都定义了“相同名称之函数”，那么通过对象指针调用成员函数时，到底调用了那个函数，必须视该指针的原始类型而定，而不是视指针实际所指的对象的类型而定，这与第1点其实意义相通。
4. 