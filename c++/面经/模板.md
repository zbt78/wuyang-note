`虚函数不能是模板函数,类成员函数可以是模板函数.`

### 模板编译过程
模板编译过程是一个复杂的阶段，包括两个主要阶段：模板实例化和模板实例化后的代码生成。
1. 模板定义阶段：
   ```c++
   template <typename T> T add(T a, T b) { return a + b; }
   ```

2. 模板实例化阶段：
  1. 当你在程序中使用模板时，编译器需要生成特定类型的实例以用于编译。这个过程称为模板实例化。 

  2. 当编译器看到对模板的使用时，它会尝试生成模板的具体实例，替换模板参数的具体类型。

  	```c++
  	int result = add<int>(3, 5);
  	```

  	在这个例子中，编译器会生成 `add<int>` 的实例，将 `T` 替换为 `int`。

3. 模板实例化后的代码生成：

    1. 在模板实例化完成后，编译器将生成特定类型的代码。

     2. 这包括将模板参数替换为实际类型，并生成函数或类的具体实现。

    	```c++
    	int add(int a, int b) {
    	    return a + b;
    	}
    	```

    	这是模板实例化后的代码，其中 `T` 已经被替换为 `int`。

4. **编译器优化：**

    1. 在生成代码之后，编译器可能会执行一些优化步骤以提高代码的性能。

总结：

当编译器遇到一个template时，不能够立马为他产生机器代码，它必须等到template被指定某种类型。也就是说，函数模板和类模板的完整定义将出现在template被使用的每一个角落，比如遇到`int result = add<int>(3, 5);`时，才能确定编译内容，否则**编译器没有足够的信息产生机器代码**。

对于不同的编译器，其对模板的编译和链接技术也会有所不同，其中一个常用的技术称之为Smart，其基本原理如下：

1. 模板编译时，以每个cpp文件为编译单位，实例化该文件中的函数模板和类模板
2. 链接器在链接每个目标文件时，会检测是否存在相同的实例；有存在相同的实例版本，则删除一个重复的实例，保证模板实例化没有重复存在。

比如我们有一个程序，包含A.cpp和B.cpp，它们都调用了CThree模板类，在A文件中定义了int和double型的模板类，在B文件中定义了int和float型的模板类；在编译器编译时.cpp文件为编译基础，生成A.obj和B.obj目标文件，即使A.obj和B.obj存在重复的实例版本，但是在链接时，链接器会把所有冗余的模板实例代码删除，保证exe中的实例都是唯一的。

